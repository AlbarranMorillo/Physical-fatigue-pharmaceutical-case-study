# -*- coding: utf-8 -*-
"""Physical_fatigue_classifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CMPmdR8vx38dJbgA6WYewOommWWR0Og2
"""

import numpy as np
import pandas as pd
import pylab as pl
from scipy.stats import norm

def find_intersection_point(x,y1,y2):
    intersection_x = None
    min_diff = float('inf')

    for i in range(len(x) -1):
      if (y1[i] > y2[i] and y1[i+1] < y2[i+1]) or (y1[i] < y2[i] and y1[i+1] > y2[i+1]):
        # Linear interpolation to estimate intersection point
        intersection_x = x[i] + (x[i+1] - x[i]) * (y1[i] - y2[i]) / (y1[i] - y1[i+1] - (y2[i] -y2[i+1]))
        return intersection_x, y1[i]

    return intersection_x, y[i]

from google.colab import drive
drive.mount('/content/drive') # Removed extra indentation


file_path = '/content/drive/MyDrive/SMARTWATCH + OCRA (FIXED).xlsx'
df = pd.read_excel(file_path)
df_fuzzy = pd.read_excel('/content/drive/MyDrive/data_processed_by_PCA.xlsx', sheet_name='label_fuzzylogic')
df_fuzzy.head()

df_pc = pd.read_excel('/content/drive/MyDrive/data_processed_by_PCA.xlsx', sheet_name='pc_value_calculated')
df_pc.head()

df = pd.concat([df_pc, df_fuzzy[['Fuzzy_pc','p_nonfatigue','p_fatigue','belonging_nonfatigue','belonging_fatigue']]], axis=1)
df.head()

pl.hist(df['Fuzzy_pc'])

def normal(x,mean,std):
  return 1/(std*np.sqrt(2*np.pi)) * np.exp(-0.5*((x-mean)/std)**2)

def pdf_fatigue(x):
  return normal(x,-0.7079,0.7201)

def pdf_non_fatigue(x):
  return normal(x,0.5491,0.7805)

pl.plot(df['Fuzzy_pc'], pdf_non_fatigue(df['Fuzzy_pc']), '.', color='red', label='Non-Fatigue')
pl.plot(df['Fuzzy_pc'], pdf_fatigue(df['Fuzzy_pc']), '.', color='blue', label='Fatigue')
pl.legend()
pl.show()

"""# 2-Class Physical Fatigue Classifier"""

x_cfd = np.sort(df['IPC1'])
y1_cfd = 1-np.sort(df['belonging_nonfatigue'])
y2_cfd = np.sort(df['belonging_fatigue'])
pl.plot(x_cfd, y1_cfd, label='Non-fatigue state', color='red', linewidth=2)
pl.plot(x_cfd, y2_cfd, label='Fatigue state', color='blue', linewidth=2)
pl.grid()
pl.ylabel('Degree of belonging')
pl.xlabel('Component 1')
x_i, y_i = find_intersection_point(x_cfd, y1_cfd, y2_cfd) # Find the intersection point (x,y) of CDF curves
pl.vlines(x_i, 0,1, linestyle='--', color='black', linewidth=1.5)
# pl.hlines(y_i, min(df['IPC1']), max(df['IPC1']), linestyle='--', color='black', linewidth=1.5) # Plot Horizontal Line
pl.text(-2,0.3,"Non-fatigue state", rotation=90)
pl.text(2,0.35,"Fatigue state", rotation=90)
pl.ylim(-0.002,1.002)
pl.xlim(min(x_cfd), max(x_cfd))
pl.title('Membership Function')
pl.text(6,1.01,r'$CDF_{fatigue}(x)$')
pl.text(-3.8,1.01,r'1-$CDF_{nonfatigue}(x)$')
pl.legend()
pl.show()

df['2-class'] = np.zeros(len(df))+3 # To validate assignation
df.loc[ (df['belonging_fatigue'] > y_i,'2-class') ]  = 1 # Defining Target, Fatigue:1, Non-fatigue:0
df.loc[ (df['belonging_fatigue'] < y_i,'2-class') ]  = 0
np.unique(df['2-class'])

x_cfd = np.sort(df['IPC1'])
y1_cfd = 1-np.sort(df['belonging_nonfatigue'])
y2_cfd = np.sort(df['belonging_fatigue'])
ii_y1sort = np.argsort(1-df['belonging_nonfatigue'])
ii_y2sort = np.argsort(df['belonging_fatigue'])


pl.scatter(x_cfd, y1_cfd, label='Non-fatigue state', c=df['2-class'][ii_y1sort], linewidth=2)
pl.scatter(x_cfd, y2_cfd, label='Fatigue state', c=df['2-class'][ii_y2sort], linewidth=2)
pl.grid()
pl.ylabel('Degree of belonging')
pl.xlabel('Component 1')
x_i, y_i = find_intersection_point(x_cfd, y1_cfd, y2_cfd) # Find the intersection point (x,y) of CDF curves
pl.vlines(x_i, 0,1, linestyle='--', color='black', linewidth=1.5)
# pl.hlines(y_i, min(df['IPC1']), max(df['IPC1']), linestyle='--', color='black', linewidth=1.5) # Plot Horizontal Line
pl.text(-2,0.3,"Non-fatigue state", rotation=90)
pl.text(2,0.35,"Fatigue state", rotation=90)
pl.ylim(-0.002,1.002)
pl.xlim(min(x_cfd), max(x_cfd))
pl.title('Membership Function')
pl.text(6,1.01,r'$CDF_{fatigue}(x)$')
pl.text(-3.8,1.01,r'1-$CDF_{nonfatigue}(x)$')

pl.show()

df[['belonging_fatigue','belonging_nonfatigue','2-class']].head() # Defining Target, Fatigue:1, Non-fatigue:0

biclass_mapping = {1: 'Fatigue', 0: 'Non-fatigue'}

pl.hist(df['2-class'], bins=[-0.5, 0.5, 1.5], align='mid', rwidth=0.8)
pl.xticks([0, 1], [ biclass_mapping[i] for i in [0,1] ])
pl.xlabel('Physical Fatigue State')
pl.ylabel('Frequency')
pl.title('Histogram of Physical Fatigue State')
pl.show()

"""## ML Classification"""

from scipy.stats import norm
from sklearn.model_selection import train_test_split, cross_val_score, KFold
from sklearn.metrics import f1_score, confusion_matrix, ConfusionMatrixDisplay
from sklearn.preprocessing import LabelEncoder, StandardScaler
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier

"""### External Features"""

X = df[['EPC1', 'EPC2', 'Moment', 'Day']]
y = df['2-class']

scaler = StandardScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

classifiers = {
    'Random Forest': RandomForestClassifier(random_state=42),
    'Logistic Regression': LogisticRegression(random_state=42),
    'SVM': SVC(random_state=42),
    'KNN': KNeighborsClassifier()
}

for name, clf in classifiers.items():
  kfold = KFold(n_splits=5, shuffle=True, random_state=42)  # 5-fold cross-validation
  cv_scores = cross_val_score(clf, X_train, y_train, cv=kfold, scoring='f1')

  clf.fit(X_train, y_train)
  y_pred = clf.predict(X_test)
  f1 = f1_score(y_test, y_pred)
  cm = confusion_matrix(y_test, y_pred, normalize='true')
  disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=np.array(list(biclass_mapping.values()))[::-1])
  disp.plot()
  plt.title(f'{name} - Normalized Confusion Matrix')
  plt.show()

  print(f"{name}:")
  print(f"  Cross-validation F1 scores: {cv_scores}")
  print(f"  Mean F1 score: {np.mean(cv_scores)}")
  print(f"  Test F1 score: {f1}")
  print("-" * 20)

"""### External + Internal Features"""

X = df[['IPC1', 'IPC2','EPC1', 'EPC2', 'Moment', 'Day']]
y = df['2-class']

scaler = StandardScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

classifiers = {
    'Random Forest': RandomForestClassifier(random_state=42),
    'Logistic Regression': LogisticRegression(random_state=42),
    'SVM': SVC(random_state=42),
    'KNN': KNeighborsClassifier()
}

for name, clf in classifiers.items():
  kfold = KFold(n_splits=5, shuffle=True, random_state=42)  # 5-fold cross-validation
  cv_scores = cross_val_score(clf, X_train, y_train, cv=kfold, scoring='f1')

  clf.fit(X_train, y_train)
  y_pred = clf.predict(X_test)
  f1 = f1_score(y_test, y_pred)
  cm = confusion_matrix(y_test, y_pred, normalize='true')
  disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=np.array(list(biclass_mapping.values()))[::-1])
  disp.plot()
  plt.title(f'{name} - Normalized Confusion Matrix')
  plt.show()

  print(f"{name}:")
  print(f"  Cross-validation F1 scores: {cv_scores}")
  print(f"  Mean F1 score: {np.mean(cv_scores)}")
  print(f"  Test F1 score: {f1}")
  print("-" * 20)

"""# 4-Class Physical Fatigue Classifier"""

x_cfd = np.sort(df['IPC1'])
y1_cfd = 1-np.sort(df['belonging_nonfatigue'])
y2_cfd = np.sort(df['belonging_fatigue'])
pl.plot(x_cfd, y1_cfd, label='Non-fatigue state', color='red', linewidth=2)
pl.plot(x_cfd, y2_cfd, label='Fatigue state', color='blue', linewidth=2)
pl.grid()
pl.ylabel('Degree of belonging')
pl.xlabel('Component 1')
x_i, y_i = find_intersection_point(x_cfd, y1_cfd, y2_cfd) # Find the intersection point (x,y) of CDF curves
pl.vlines(x_i, 0,1, linestyle='--', color='black', linewidth=1.5)
pl.vlines(x_i+0.86, 0,1, linestyle='--', color='black', linewidth=1.5) # Painted byhand
pl.vlines(x_i-1.16, 0,1, linestyle='--', color='black', linewidth=1.5) # Painted byhand
# pl.hlines(y_i, min(df['IPC1']), max(df['IPC1']), linestyle='--', color='black', linewidth=1.5) # Plot Horizontal Line
pl.text(-2,0.3,"Pure non-fatigue state", rotation=90)
pl.text(2,0.35,"Pure Fatigue state", rotation=90)
pl.text(-0.6,0.3,"Higher non-fatigue state", rotation=90)
pl.text(0.8,0.3,"Higher fatigue state", rotation=90)
pl.ylim(-0.002,1.002)
pl.xlim(min(x_cfd), max(x_cfd))
pl.title('Membershi3 Function')
pl.text(6,1.01,r'$CDF_{fatigue}(x)$')
pl.text(-3.8,1.01,r'1-$CDF_{nonfatigue}(x)$')
pl.legend()
pl.show()

df['4-class'] = np.zeros(len(df))+5
df.loc[(df['belonging_fatigue'] >= 0.99), '4-class'] = 3  # Pure Fatigue
df.loc[(df['belonging_fatigue'] > y_i) & (df['belonging_fatigue'] < 0.99), '4-class' ] = 2 # Higher Fatigue
df.loc[(df['belonging_fatigue'] > 0.01) & (df['belonging_fatigue'] < y_i), '4-class'] = 1 # Higher Non-fatigue
df.loc[(df['belonging_fatigue'] <= 0.01), '4-class'] = 0 # Pure non-fatigue

np.unique(df['4-class']), y_i

multiclass_mapping = {3: 'Pure \nfatigue', 2: 'Higher \nfatigue', 1: 'Higher \nnon-fatigue', 0: 'Pure \nnon-fatigue'}

pl.hist(df['4-class'], bins=[-0.5, 0.5, 1.5, 2.5, 3.5], align='mid', rwidth=0.8)
pl.xticks([0, 1, 2, 3], [multiclass_mapping[i] for i in [0, 1, 2, 3]])
pl.xlabel('Physical Fatigue State')
pl.ylabel('Frequency')
pl.title('Histogram of Physical Fatigue State (4-Class)')
pl.show()

ii_y1sort = np.argsort(1-df['belonging_nonfatigue'])
ii_y2sort = np.argsort(df['belonging_fatigue'])

pl.scatter(x_cfd, y1_cfd, marker='.', label='Non-fatigue state', c=df['4-class'][ii_y1sort], linewidth=2)
pl.scatter(x_cfd, y2_cfd, marker='.', label='Fatigue state', c=df['4-class'][ii_y1sort], linewidth=2)
pl.grid()
pl.ylabel('Degree of belonging')
pl.xlabel('Component 1')
x_i, y_i = find_intersection_point(x_cfd, y1_cfd, y2_cfd) # Find the intersection point (x,y) of CDF curves
pl.vlines(x_i, 0,1, linestyle='--', color='black', linewidth=1.5)
pl.vlines(x_i+0.86, 0,1, linestyle='--', color='black', linewidth=1.5) # Painted byhand
pl.vlines(x_i-1.16, 0,1, linestyle='--', color='black', linewidth=1.5) # Painted byhand
# pl.hlines(y_i, min(df['IPC1']), max(df['IPC1']), linestyle='--', color='black', linewidth=1.5) # Plot Horizontal Line
pl.text(-2,0.3,"Non-fatigue state", rotation=90)
pl.text(2,0.35,"Fatigue state", rotation=90)
pl.text(-0.6,0.3,"Higher non-fatigue state", rotation=90)
pl.text(0.75,0.3,"Higher fatigue state", rotation=90)
pl.ylim(-0.002,1.002)
pl.xlim(min(x_cfd), max(x_cfd))
pl.title('Membership Function')
pl.text(6,1.01,r'$CDF_{fatigue}(x)$')
pl.text(-3.8,1.01,r'1-$CDF_{nonfatigue}(x)$')
# pl.legend()
pl.show()

"""## ML Classification

### External Features
"""

X = df[['EPC1', 'EPC2', 'Moment', 'Day']]
y = df['4-class']

scaler = StandardScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

classifiers = {
    'Random Forest': RandomForestClassifier(random_state=42),
    'Logistic Regression': LogisticRegression(random_state=42),
    'SVM': SVC(random_state=42),
    'KNN': KNeighborsClassifier()
}

for name, clf in classifiers.items():
  kfold = KFold(n_splits=5, shuffle=True, random_state=42)  # 5-fold cross-validation
  cv_scores = cross_val_score(clf, X_train, y_train, cv=kfold, scoring='f1_weighted')

  clf.fit(X_train, y_train)
  y_pred = clf.predict(X_test)
  f1 = f1_score(y_test, y_pred, average='weighted')
  cm = confusion_matrix(y_test, y_pred, normalize='true')
  disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=np.array(list(multiclass_mapping.values()))[::-1])
  disp.plot()
  plt.title(f'{name} - Normalized Confusion Matrix')
  plt.show()

  print(f"{name}:")
  print(f"  Cross-validation F1 scores: {cv_scores}")
  print(f"  Mean F1 score: {np.mean(cv_scores)}")
  print(f"  Test F1 score: {f1}")
  print("-" * 20)

"""### External + Internal Features"""

X = df[['IPC1', 'IPC2','EPC1', 'EPC2', 'Moment', 'Day']]
y = df['4-class']

scaler = StandardScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

classifiers = {
    'Random Forest': RandomForestClassifier(random_state=42),
    'Logistic Regression': LogisticRegression(random_state=42),
    'SVM': SVC(random_state=42),
    'KNN': KNeighborsClassifier()
}

for name, clf in classifiers.items():
  kfold = KFold(n_splits=5, shuffle=True, random_state=42)  # 5-fold cross-validation
  cv_scores = cross_val_score(clf, X_train, y_train, cv=kfold, scoring='f1_weighted')

  clf.fit(X_train, y_train)
  y_pred = clf.predict(X_test)
  f1 = f1_score(y_test, y_pred, average='weighted')
  cm = confusion_matrix(y_test, y_pred, normalize='true')
  disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=np.array(list(multiclass_mapping.values()))[::-1])
  disp.plot()
  plt.title(f'{name} - Normalized Confusion Matrix')
  plt.show()

  print(f"{name}:")
  print(f"  Cross-validation F1 scores: {cv_scores}")
  print(f"  Mean F1 score: {np.mean(cv_scores)}")
  print(f"  Test F1 score: {f1}")
  print("-" * 20)

"""# Summary.  

- First, I defined a 2-class and a 4-class fatigue classification based on the intersection points of cumulative distribution functions (CDFs) derived from the data. As you can see in the Figures.

- Then, I test different classification algorithms (Random Forest, Logistic Regression, SVM, and KNN) for the binary and the mulclass problems.
For this test, two sets of features were tested:  "external features" (EPC1, EPC2, Moment, Day) and "external + internal features" (including IPC1 and IPC2).

**Key Results:**

- The analysis shows F1 scores (and confusion matrices) for each classifier and feature set (2 o 4-class) after a cross validation process with k=5, using external and external+internal features. In both cases you can see that just External is not enough to get a good score.


| Problem | Feature Set | Best classifier | F1 |
|----------|-------------|------|------|
| 2-Class | Ext | Random Forest | 0.68 |
| 2-Class | Ext+Int | Random Forest | 0.93 |
| 4-Class | Ext | Random Forest | 0.57 |
| 4-Class | Ext+Int | Random Forest | 0.90 |
"""

